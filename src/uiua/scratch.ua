# ⊃⋅'↘2⊙⊃'⊡1⊢ 9 [0 1 1 6]
# ∶⊙⊃⊃'↘2'⊡1⊢ 9 [0 1 1 6]
# ∶⊙⊃'↘2(∩⊡1,0) 9 [0 1 1 6]

# ∩⊡1,2⇡10

# ┌╴/Users/mk/Code/aoc/src/uiua/2022_05.ua:12:55
# ├╴[0 1 1 6]
# ├╴[⌜V⌟ ⌜SDSL⌟ ⌜WC⌟ ⌜⌟ ⌜TSHNWCBTFCDMTBJVBWPNBM⌟ ⌜CNWGTF⌟ ⌜VBGZDWCN⌟ ⌜⌟ ⌜ZVZJSGQFLRPGM⌟]
# └╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴
# ┌╴/Users/mk/Code/aoc/src/uiua/2022_05.ua:12:39
# ├╴0
# ├╴1
# ├╴[⌜V⌟ ⌜SDSL⌟ ⌜WC⌟ ⌜⌟ ⌜TSHNWCBTFCDMTBJVBWPNBM⌟ ⌜CNWGTF⌟ ⌜VBGZDWCN⌟ ⌜⌟ ⌜ZVZJSGQFLRPGM⌟]
# ├╴[1 6]
# └╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴╴

# ∺-0_1_1↯4_3⇡12

# 0_1_1
# ↧1⇡3

# /∘⊏1_2 ⇡10

# 0_1_1
# ↧1⇡3
# ⋯6

# ⧻ □[1 2]

# =.NaN

# Dict ← ⍉[{"test" 50} {"testert" 60}]
# GetFromDict ← ⊡⊗□⊙⍘⊟
# GetFromDict "test" Dict

# ▽ [3 1 2] +1⇡ 3

# Ways of doing 2022_01:
# Sorted calorie sums for each elf.
# .⊏⍖.⊜/+≠∞.⊕(?⋅∞parse=0⧻.)⍜▽¯∶\+.=@\n.
# .⊏⍖.⊜(/+⊜parse≠@\n.)¬⊂0⌕"\n\n".
# .⊏⍖.⊜(/+⊜parse≠@\n.)↥↻1.≠@\n.
# .⊏⍖.⊕/+⊃(▽∶+1⇡⧻.⊜/+¬⬚×1↘1..⊂1¬)⊜parse≠@\n.

# Ways of doing "between"
# ×≥0,≤9. 3
# ×⊓≥≤0,9 3
# ≤0×∩-0,9

# Ways of testing if digit
# ≤5⌵-@5
# ×≥@0,≤@9

# ↙5⊜(?{≍"..".}{2/+⊜parse×≥@0,≤@9.}=@c⊃'⊡1'↘4↘¯1)≠@$.

# ⍜(⊔⊡1)⊂ {0 [34] 0} 122

# ⍜⊡; 1 [0 0 0] 5

# Getting all four directions of matrix
# [⍉,⍉,⇌.]
# ≑≃⋄(⍥⍉⊙⍥⇌∩⊏0,1)⇡2_2
# ≡(⍉⇌|⇌|⍉|∘) ⇡4 ≡\↥ [⇌,⇌,⍉.].

# Shifting by 1
# ⬚¯1⊂[]↘¯1\↥
# ⍜⊢(-1×0)↻¯1\↥
# ⍜⊢¯↻¯1\↥ # can just negate, doesn't need to be exactly -1

# ◳~~⋄'+× .⇡3 100

# m! ← ∵^1⇡2;

# ⍜(⍥⍉⊙⍥⇌)∘ 1 1 "abc"

# 2022_08
# ≑∸≃⊏∶-∶⇡⧻.s0\(+×=0,)×⇡⧻.≑⋄∸≥⇡10.
# ≑∸≃⊏∶-∶⇡⧻.s0\(+×=0,)×⇡⧻.⍉⊞≥⇡10.

# # Given a fill value, shifts rows down, dropping the last one.
# s ← ⬚∘⊂.⊙'↘¯1
# s ← ⍜⊢∵⋅∘↻¯1∶

# ⍜(⍥⍉⊙⍥⇌)∘ 0 0 ↯3_3⇡9
# q! ← ◳~~⋄(⍜(⍥⍉⊙⍥⇌)^1).⇡2
# q!∘ ↯3_3⇡9

# ⊏∶1_¯1_0⊗∶"RL"_"UD" @R
# ⊏∶⊂¯.⊞=.⇡2 ⊗∶"RULD" @R

# 2022_09
# ⊐/⊂⊜(□↯⊃(parse↘2)(⊏∶1_¯1_0⊗∶"RL"_"UD"⊢)) ≠@\n.
# ⊜(×⊃(parse↘2)(⊏∶1_¯1_0⊗∶"RL"_"UD"⊢))≠@\n.
# ⊜(×⊏∶1_¯1_0⊗∶"RL"_"UD"⊃⊢(parse↘2))≠@\n.

# [[[0 9 0] [0 2 0]]
#  [[1 8 1] [1 1 1]]]

# [[1 0] [0 2]]

# ⍜♭≡⊏⊙(☇1)

# ▽ . [0 1 2 0 0]

# ⊜□≠@,."one,two,three,four,five,six,seven,eight,nine"

# # 2023_02
# "7 blue, 3 green, 2 red"
# ⬚0⊏⊃(⊗"rgb"▽×⊃(≥@a)(↻¯1=@ ))(⊜parse×≥@0,≤@9.).

# ⊜(□⊜(⬚0⊏⊃(⊗"rgb"▽×⊃(≥@a)(↻¯1=@ ))(⊜parse×≥@0,≤@9.).)≠@;.↘+2⊗@:.)≠@\n.

# /++1⊚≡(/×/×≡≤¤+12⇡3)

# # 2023_03
# ×¬,≠@.,×⊃(≥@0)(≤@9).
# ×¬,⊃(≠@.)(×⊃(≥@0)(≤@9)).
# △/⊂/⊂⊠(↻⊂).⇡3¤
# △≡↻/⊂-1⇡3_3¤

# ⁿ:2⇡100

# /↥≡⬚0↻/⊂-1⇡3_3¤ [1_0_0_0 0_0_0_0 0_1_0_0 0_0_0_0]

# ⍜♭(×:\+×¬↻¯1..) [1_1_1_0 0_1_1_0 1_0_0_0]

# ▽±. 1_0_3_8

# -1▽≠1≡/×./⊂⇡3_3
# ▽≡/↥≠0./⊂-1⇡3_3
# ▽≡/↥≠0./⊂-1⇡3_3
# [⍥(⍜⊢¯⇌.)8 1_0]

# +⊃∘⋅⋅∘ 1 2 3

# ⬚∘(↻1) 7 ⇡3

# ⊃(⬚∘(↻1))(⊂⊙;)+1/+×, [1 0 1] [7 8 9] []

# 2023_05

# ≡+¤1⊏⇡2⍉[50_98_2 52_50_48]

# ⍉[50_98_2 52_50_48] 79
# ⊏⊃(¬/↥|⊟/+×)×⊃(≥0;|≤⊏2|+⊢)⊃(∘|-⊏1|⋅∘)

# ⍉[50_98_2 52_50_48] [79 14 79]
# ≡⊏⊃(¬/↥|≡⊟/+×)×⊃(≥0;|≤⊏2|+⊢)⊃(∘|⊞-⊏1|⋅∘)

# dst_src_len
# ⍉[50_98_2 52_50_48] [79 79] [14 14]
# before: delta=v-79, check ≥0 && < 2, add to 50

# #### SINGLE VALUE TRANSFORMATION
# 79 orig
# 98{+2} src
# 50{+2} dst  => -48, clip to ≥50 <52
# 79-48=31, out of range
# 79+2=81, clip to ≥52 <100, good. ---> 81

# #### RANGE TRANSFORMATION
# 79{+14} orig
# 98{+2} src
# 50{+2} dst  => -48, clip to ≥50 <52
#       [79,93)
# -48 = [31,45)
# intersect [50,52) = {}
#       [79,93)
#  +2 = [81,95)
# intersect [52,100) = [81, 95)

# at each step:
# - take all ranges
# - transform all by all maps (table)
# - flatten, sort, merge (incl. eliminate empty)
# there are 10 seed ranges & 7 maps with >10 entries each,
# so without merge it would result in > 10*10^7 ranges

# [¯48_2 50_52 52_100] [79 14 78 14 77 14]
# T_2_S -> ≡⍉⍉ -> 2_T_S (T = number transformations in map, S = num seed ranges)
# ∩♭⊓↥↧⊙:⊃(∩⊏1,2|⍘⊟≡⍉⍉⊞+⊢)⊙(\+⍉↯¯1_2) # final clamped (some have low≥hi, those are empty)

# [5,15) apply [10,20) => [20,30)  (+10)
# [15,25) -> clip -> [20,25)
# find ranges that lie in NONE of the domains -> add to list unchanged
# THEN sort and merge
# hmm maybe for first part should clip THEN transform
# clip -> bad, good. transform only good. include both
# no! not both, only include old range portions that are in NONE of the transformations
# ok take original reverse clipped (meaning potentially split in two)
# and intersect all those
# [¯48_2 50_52 52_100] [79 14 78 14 77 14]
# ⊙(\+⍉↯¯1_2)

# Trying to change from dest min/max to source min/max
[50_52 98_50 2_48] [79 100]
⍜⍘[⊙⊙∘]⊃(-:|⋅∘|+;)
×⊓⊞≥⊞<⊃(⊙,∩⊏1,2|⊞+⊢|⋅∘)
≡⊏⊃(¬/↥|≡⊟/+×)
# ×⊓≥<⊙,⊃(∩⊏1,2|.⊞+⊢|⋅∘)
# actually maybe dest min/max was better b/c only need to do ⊞ once?
# but src will be better for getting outside regions

# # Converting the input mappings into [delta min max].
# dst_src_len
# ⍉[50_98_2 52_50_48] [79 79] [14 14]
# [⊃(-∩⊏1,0|⊢|+∩⊏0,2)]
# [⊙⊃∘+-⊙.:⍘[⊙⊙∘]]
# ⍜⍘[⊙⊙∘](⊙⊃∘+-⊙.:)
# [⊃(-:|∘|+⊙;)⍘[⊙⊙∘]]
# ⍜⍘[⊙⊙∘]⊃(-:|∘|+⊙;) # best one :-)
# a b c
# b a c
# b a a c
# (-b a) a (+a c)
