
# Gets an environment variable.
Env â† {Â¯1â†“1âŠ‘ â€¢SH âŸ¨"printenv", ğ•©âŸ©}

# The problem input path (first command line argument).
Path â† {ğ•Š: â€¢wdpath â€¢file.At âŠ‘ â€¢args}

# Newline character.
nl â‡ @+10

# Splits a list of strings on empty strings, returning a list of lists.
# SplitEmpty â‡ ((âŠ£-Ëœ+`Ã—Â¬)0=â‰ Â¨)âŠ¸âŠ”

e â† âŸ¨"ab", "c", "", "de", "", "", "g"âŸ©
""âŠ¸â‰¡_split e
0âŠ¸=_split âŸ¨1, 2, 0, 3, 4, 5, 0, 0, 7âŸ©
ns â† âŸ¨4, 4, 1, 1, 3, 4, 1, 6, 1, 2âŸ©
1 â‰  ns
Â» 1 â‰  ns
+` Â»âŠ¸> 1 â‰  ns
1âŠ¸=_cut ns

# Trying to get the index of first one and use that was not worth it.
# Just use / and take the first element after that.
x â† âŠ‘Â¨(âˆŠ/âŠ£)ËÂ¨ 2â€¿âˆ˜âŠ¸â¥ŠÂ¨ Lines "2022_03"
x â† (âŠ‘(âˆŠ/âŠ£)Ë)Â¨ 2â€¿âˆ˜âŠ¸â¥ŠÂ¨ Lines "2022_03"
x â† (âŠ£âŠ‘Ëœ(âŠ‘Â·âŠâŸœ1âˆŠ))ËÂ¨ 2â€¿âˆ˜âŠ¸â¥ŠÂ¨ Lines "2022_03"

âŸ¨nâ†“âŠ£, âŠ¢âˆ¾ËœÂ·ğ”½nâ†‘âŠ£âŸ©âŠ¸({ğ•Â´ğ•©}âš‡Â¯1â€¿âˆ)âŒ¾(srcâ€¿dstâŠ¸âŠ)ğ•©



S â† ' 'âŠ¸=âŠ¸Split
x â† (1-ËœÂ·+`'$'=âŠ‘Â¨)âŠ¸âŠ” Lines "2022_07"

>((S 2â†“âŠ‘)(âŠâˆ˜âŠ£âˆ¾(1â†“âŠ£)â‹ˆâŠ¢)(1âŠ¸âŠ‘Â¨Â·("dir"â‰¡âŠ‘)Â¨âŠ¸/Â·SÂ¨1âŠ¸â†“))Â¨ x
>((S 2â†“âŠ‘)(âŠâˆ˜âŠ£âˆ¾(1â†“âŠ£)â‹ˆâŠ¢)(NÂ¨âŒ¾âŠË˜âŒ¾âŠ‘Â·1âŠ¸âŠË˜âŒ¾(1âŠ¸âŠ‘)Â·>Â¨Â·(2âˆ¾Ëœ("dir"â‰¡âŠ‘)Â¨)âŠ¸âŠ”Â·SÂ¨1âŠ¸â†“))Â¨ x

# ParseOut â† NÂ¨âŒ¾(âŠË˜âŠ‘)Â·1âŠ¸âŠË˜âŒ¾(1âŠ¸âŠ‘)Â·>Â¨Â·(2âˆ¾Ëœ'd'=âŠ‘âŸ2Â¨)âŠ¸âŠ”Â·' 'âŠ¸=âŠ¸SplitÂ¨1â†“âŠ¢
# ParseOut â† âŸ¨NÂ¨âŒ¾âŠË˜,1âŠ¸âŠË˜âŸ©{ğ•ğ•©}Â¨Â·>Â¨Â·(2âˆ¾Ëœ'd'=âŠ‘âŸ2Â¨)âŠ¸âŠ”Â·' 'âŠ¸=âŠ¸SplitÂ¨1â†“âŠ¢

# Storing 1s and 0s instead of cd and ls
# ParseCmd â† ("cd"âŠ¸â‰¡âŸœâŠ‘â‹ˆ1â†“âŠ£)Â·' 'âŠ¸=âŠ¸Split 2â†“âŠ‘

# Returns the subtree of ğ•© for directory ğ•¨.
# Subtree â† {0=â‰ ğ•¨ ? ğ•© ; (1â†“ğ•¨)ğ•Š(âŠ‘âŠ¢âŠËœÂ·âŠğ•¨âŠËœâŠ‘Â¨)2â†“ğ•©}

# old way, returning a composed function
Nav â† {
  # â€¢Show âŸ¨"NAV", ğ•¨âŸ©
  0=â‰ ğ•¨ ? âŠ¢ ;
  F â† (2+(âŠ‘ğ•¨âŠËœâŠ‘Â¨)2â†“ğ•©)âŠ¸âŠ‘
  ((1â†“ğ•¨)ğ•Š F ğ•©)âˆ˜F
}

(âŠ‘Â¨2â†“t)âŠ¸âŠâŒ¾< "a"
(âŠ‘Â¨2â†“t)âŠ<"a"
"a" Cd âŸ¨âŸ©â€¿t


# âŸ¨âŸ© Nav âŸ¨"/", 10, âŸ¨"a", 5âŸ©âŸ©
# t â† âŸ¨"/", 10, âŸ¨"j", 1âŸ©, âŸ¨"a", 5, âŸ¨"q", 2âŸ©âŸ©, âŸ¨"c", 9âŸ©âŸ©
# (âŸ¨"a", "q"âŸ© Nav t)â—‹âŠ¢ t
# âŸ¨"hi"âŸ©Ë™âŒ¾(âŸ¨"a", "q"âŸ© Nav t) t
# âŸ¨123, "x"âŸ© InsertFile t


    # y â† 6â€¿3â€¿5â€¿1â€¿1â€¿4â€¿3
#       0 6 6 5 5 5 4  height of blocker
#     < 0 1 2 1 2 3 1  left viewing distance
#       0 5 0 4 4 0 0  height of blocker
#     > 6 1 4 2 1 1 0  right viewing distance

# â‹ˆâŸœ0Â¨â†•â‰ y (âŠ¢)Â´ y

#  z â† 1â€¿2â€¿2â€¿4â€¿1â€¿3â€¿2
# > 1  1 1 1 2 1 1 0
#   2  3 2 1 2 1 1 0
#   3  3 2 1 3 2 1 0
#   4  6 5 4 3 2 1 0
# < 1  0 1 1 1 1 2 1
#   2  0 1 2 3 1 2 1
#   3  0 1 2 3 1 2 3
#   4  0 1 2 3 4 5 6

# Equivalent functions (or Ëœ thereof) that give ğ•©, or ğ•¨ if ğ•© is 0.
Ã—âŸœ(0=âŠ¢)+âŠ¢
Ã—âŸœ(Â¬Ã—)+âŠ¢
âŠ£+(Â¬Ã—)âŠ¸Ã—
âŠ£+Â¬âˆ˜Ã—âŠ¸Ã—
âŠ£+0âŠ¸=âŠ¸Ã—
âŠ¢+âŠ£Ã—0=âŠ¢

# fills in gaps of ones with âˆ¨`, not sure if useful.
(âˆ¨`yâŠ¸â‰¥)Ë˜â†•10


# Ways of getting 1,0 -1,0 0,1 0,-1
(âˆ¾âŸœ-=âŒœËœâ†•2)
(1-|âˆ˜-âŸœ1)Â¨â†•4   # 1-|x-1|
(1-Ëœ|âˆ˜-âŸœ2)Â¨â†•4  # |x-2|-1

# Tail is in center, head is one of the 9 positions relative to it,
# and is moving NESW. Number in cell represents how many moves head
# can go before tail starts moving too. This means the new location
# of the tail is the first element of Nâ†“L where N is the number in
# the cell and L is the list from the head's old position (inclusive)
# to its new position (exclusive). Equivalent, the tail stays where
# it is for 1/2 and moves to the head's old position for 0.
#               Â¯1      0       1
# . . .             | 0 0 0 |      
# . T .  Â¯1         | 1 1 1 |      
# . . .             | 2 2 2 |      
#            -------+-------+-------
#             0 1 2 |       | 2 1 0
#         0   0 1 2 |       | 2 1 0
#             0 1 2 |       | 2 1 0
#            -------+-------+-------
#                   | 2 2 2 |      
#         1         | 1 1 1 |      
#                   | 0 0 0 |      
# With part 2, we can't just apply this repeatedly, because each tail
# is now a head to the next tail, and tails can move diagonally or not
# at all, so we need to fill in all the cells, not just NESW. In this
# diagram, I will focus on the top-right quadrant since others are
# symmetrical.
#
#
#
#
#
#
#              |
#              |
#              |
#              |
# -------------|--------------


#     X
#    X      X
#   X      X
#

# a = (h-t)*x+1

# Farthest head goes:
# Â¯65-490,Â¯227-100


###### VERY INTERESTING OPTIMIZATION
# In 2022_09.bqn at 116688ff12f0af995db9af489b3c7d434a102b80,
# this was 8-12ms (usually 11):
S â† {
  nâ€¿d â† ğ•¨ â‹„ hâ€¿t â† ğ•©
  e â† 1++Â´dÃ—h-ËœÂ¯1âŠt
  âŸ¨h+nÃ—d, tâˆ¾eâ†“hâŠ¸+Ë˜(â†•n)Ã—âŒœdâŸ©
}
# This (doing one at a time) was much slower, ~25ms:
S â† {
  nâ€¿d â† ğ•¨ â‹„ {
    hâ€¿t â† ğ•©
    e â† 1++Â´dÃ—h-ËœÂ¯1âŠt
    âŸ¨h+d, tâˆ¾eâ†“â‰hâŸ©
  }âŸn ğ•©
}
# But this was back down to 11ms!
S â† {
  nâ€¿d â† ğ•¨ â‹„ {
    hâ€¿t â† ğ•©
    e â† 0>+Â´dÃ—h-ËœÂ¯1âŠt
    âŸ¨h+d, hâˆ¾ËœâŸe tâŸ©
  }âŸn ğ•©
}
# Also prepending instead of appending to t was slower (15ms).
####################################
